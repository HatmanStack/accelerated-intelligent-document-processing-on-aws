# Copyright Â© Amazon.com and Affiliates: This deliverable is considered Developed Content as defined in the AWS Service Terms and the SOW between the parties.

AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: AWS GenAI IDP Accelerator (uksb-r8evguc4p9) (v0.2.0)

Parameters:
  # Auth

  AdminEmail:
    Type: String
    Description: >-
      Email address of the admin user (e.g. jdoe+admin@example.com). 
      An initial temporary password is automatically sent to this user via email.
    AllowedPattern: '^[\w.+-]+@([\w-]+\.)+[\w-]{2,6}$'

  AllowedSignUpEmailDomain:
    Type: String
    Default: ""
    Description: >-
      Email address domain (example.com) or comma separated list of email domains (example1.com,
      example2.com) allowed to signup using the web UI.
      If left empty, signup via the web UI is disabled and users will have to be created
      using Cognito.
    AllowedPattern: '^(|([\w-]+\.)+[\w-]{2,6}(, *([\w-]+\.)+[\w-]{2,6})*)$'
    ConstraintDescription: >-
      Must be empty or a list of comma separated email domains (example1.com, example2.com)

  # Workflow Configuration
  IDPPattern:
    Type: String
    Default: Pattern1 - Packet processing with Textract, SageMaker(UDOP), and Bedrock
    AllowedValues:
      - Pattern1 - Packet processing with Textract, SageMaker(UDOP), and Bedrock
      - Pattern2 - Packet processing with Textract and Bedrock
      - Pattern3 - Packet or Media processing with Bedrock Data Automation (BDA)
    Description: >-
      Built-in IDP workflow patterns - see README for pattern descriptions.

  # Pattern 1 Parameters

  Pattern1UDOPModelArtifactPath:
    Type: String
    Default: "s3://bobs-artifacts-us-east-1/udop/model.tar.gz"
    AllowedPattern: "^(|s3://.*)$"
    Description: For Pattern1, provide S3 path to the UDOP model.tar.gz file (e.g., s3://bucket-name/path/to/model.tar.gz)

  Pattern1ExtractionModel:
    Type: String
    Default: "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
    AllowedValues:
      - "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
      - "us.amazon.nova-pro-v1:0"
    Description: Model to use for Extraction

  # Pattern 2 Parameters

  Pattern2ClassificationModel:
    Type: String
    Default: "us.amazon.nova-pro-v1:0"
    AllowedValues:
      - "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
      - "us.amazon.nova-pro-v1:0"
      - "Custom Fine Tuned Classification Model"
    Description: Model to use for Classification

  Pattern2ExtractionModel:
    Type: String
    Default: "us.amazon.nova-pro-v1:0"
    AllowedValues:
      - "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
      - "us.amazon.nova-pro-v1:0"
      - "Custom Fine Tuned Extraction Model"
    Description: Model to use for Extraction

  Pattern2CustomClassificationModelARN:
    Type: String
    Default: ""
    Description: For 'Custom Fine Tuned Classification Model', specify Model ARN

  Pattern2CustomExtractionModelARN:
    Type: String
    Default: ""
    Description: For 'Custom Fine Tuned Extraction Model', specify Model ARN

  # Pattern 3 Parameters

  Pattern3BDAProjectArn:
    Type: String
    Default: ""
    AllowedPattern: "^(|^arn:aws:bedrock:[a-z0-9-]+:.+:data-automation-project/.+)$"
    Description: (Optional) Bedrock Data Automation (BDA) project ARN

  # Pipeline Configuration
  MaxConcurrentWorkflows:
    Type: Number
    Default: 800
    Description: Maximum number of concurrent workflow executions allowed
    MinValue: 1

  DataRetentionInDays:
    Type: Number
    Default: 365
    Description: Number of days to retain documents (S3) and tracking records (DynamoDB)
    MinValue: 1

  ErrorThreshold:
    Type: Number
    Default: 1
    Description: Number of workflow errors that triggers an alert (per 5 minutes)
    MinValue: 1

  ExecutionTimeThresholdMs:
    Type: Number
    Default: 30000
    Description: Maximum acceptable execution time in milliseconds before alerting (default 30000 = 30 seconds)
    MinValue: 1000

  LogRetentionDays:
    Type: Number
    Default: 30
    Description: Number of days to retain CloudWatch logs
    AllowedValues:
      [
        1,
        3,
        5,
        7,
        14,
        30,
        60,
        90,
        120,
        150,
        180,
        365,
        400,
        545,
        731,
        1827,
        3653,
      ]

Rules:
  # Pattern 1 rules

  Pattern1UDOPModelArtifactPath:
    RuleCondition:
      !Equals [
        !Ref IDPPattern,
        "Pattern1 - Packet processing with Textract, SageMaker(UDOP), and Bedrock",
      ]
    Assertions:
      - Assert: !Not [!Equals [!Ref Pattern1UDOPModelArtifactPath, ""]]
        AssertDescription: UDOP Model Artifact Path is required when IDPPattern is 'Pattern1'

  # Pattern 2 rules

  Pattern2ClassificationModelArn:
    RuleCondition:
      !Equals [
        !Ref Pattern2ClassificationModel,
        "Custom Fine Tuned Classification Model",
      ]
    Assertions:
      - Assert: !Not [!Equals [!Ref Pattern2CustomClassificationModelARN, ""]]
        AssertDescription:
          Pattern2CustomClassificationModelARN is required when 'Custom Fine Tuned Classification Model'
          is selected.

  Pattern2ExtractionModelArn:
    RuleCondition:
      !Equals [
        !Ref IDPPattern,
        "Pattern1 - Packet processing with Textract, SageMaker(UDOP), and Bedrock",
      ]
    Assertions:
      - Assert: !Not [!Equals [!Ref Pattern1UDOPModelArtifactPath, ""]]
        AssertDescription: UDOP Model Artifact Path is required when IDPPattern is 'Pattern1'

# Pattern 3 rules

Conditions:
  IsPattern1:
    !Equals [
      !Ref IDPPattern,
      "Pattern1 - Packet processing with Textract, SageMaker(UDOP), and Bedrock",
    ]
  IsPattern2:
    !Equals [
      !Ref IDPPattern,
      "Pattern2 - Packet processing with Textract and Bedrock",
    ]
  IsPattern3:
    !Equals [
      !Ref IDPPattern,
      "Pattern3 - Packet or Media processing with Bedrock Data Automation (BDA)",
    ]
  ShouldAllowSignUpEmailDomain:
    !Not [!Equals [!Ref AllowedSignUpEmailDomain, ""]]

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "User Authentication"
        Parameters:
          - DeployWebUI
          - AdminEmail
          - AllowedSignUpEmailDomain
      - Label:
          default: "Workflow Pattern Selection"
        Parameters:
          - IDPPattern
      - Label:
          default: "Pattern 1 Configuration"
        Parameters:
          - Pattern1UDOPModelArtifactPath
          - Pattern1ExtractionModel
      - Label:
          default: "Pattern 2 Configuration"
        Parameters:
          - Pattern2ClassificationModel
          - Pattern2ExtractionModel
          - Pattern2CustomClassificationModelARN
          - Pattern2CustomExtractionModelARN
      - Label:
          default: "Pattern 3 Configuration"
        Parameters:
          - Pattern3BDAProjectArn
      - Label:
          default: "Processing Configuration"
        Parameters:
          - MaxConcurrentWorkflows
          - DataRetentionInDays
          - ErrorThreshold
          - ExecutionTimeThresholdMs
          - LogRetentionDays

    ParameterLabels:
      DeployWebUI:
        default: "Deploy Web UI"
      AdminEmail:
        default: "Admin Email Address"
      AllowedSignUpEmailDomain:
        default: "Allowed Sign Up Email Domain"
      IDPPattern:
        default: "Prefdefined Document Processing Pattern"
      Pattern1UDOPModelArtifactPath:
        default: "Pattern1 - UDOP Model Artifact Path"
      Pattern1ExtractionModel:
        default: "Pattern1 - Extraction Model"
      Pattern2ExtractionModel:
        default: "Pattern1 - Extraction Model"
      Pattern2CustomClassificationModelARN:
        default: "Pattern2 - Custom Classification Model ARN"
      Pattern2CustomExtractionModelARN:
        default: "Pattern2 - Custom Extraction Model ARN"
      Pattern3BDAProjectArn:
        default: "Pattern3 - Packet or Media processing with Bedrock Data Automation (BDA) Project ARN"
      MaxConcurrentWorkflows:
        default: "Maximum Concurrent Workflows"
      DataRetentionInDays:
        default: "Data Retention Period (days)"
      ErrorThreshold:
        default: "Error Alert Threshold"
      ExecutionTimeThresholdMs:
        default: "Execution Time Threshold (ms)"
      LogRetentionDays:
        default: "Log Retention Period (days)"

Resources:
  # Nested stack for selected pattern

  PATTERN1STACK:
    Type: AWS::CloudFormation::Stack
    Condition: IsPattern1
    Properties:
      # yamllint disable rule:line-length
      TemplateURL: ./patterns/pattern-1/.aws-sam/packaged.yaml
      Parameters:
        StackName: !Ref AWS::StackName
        InputBucket: !Ref InputBucket
        WorkingBucket: !Ref WorkingBucket
        OutputBucket: !Ref OutputBucket
        CustomerManagedEncryptionKeyArn: !GetAtt CustomerManagedEncryptionKey.Arn
        LogRetentionDays: !Ref LogRetentionDays
        ExecutionTimeThresholdMs: !Ref ExecutionTimeThresholdMs
        UDOPModelArtifactPath: !Ref Pattern1UDOPModelArtifactPath
        ExtractionModel: !Ref Pattern1ExtractionModel

  PATTERN2STACK:
    Type: AWS::CloudFormation::Stack
    Condition: IsPattern2
    Properties:
      TemplateURL: ./patterns/pattern-2/.aws-sam/packaged.yaml
      Parameters:
        StackName: !Ref AWS::StackName
        InputBucket: !Ref InputBucket
        WorkingBucket: !Ref WorkingBucket
        OutputBucket: !Ref OutputBucket
        CustomerManagedEncryptionKeyArn: !GetAtt CustomerManagedEncryptionKey.Arn
        LogRetentionDays: !Ref LogRetentionDays
        ExecutionTimeThresholdMs: !Ref ExecutionTimeThresholdMs
        ClassificationModel: !Ref Pattern2ClassificationModel
        ExtractionModel: !Ref Pattern2ExtractionModel
        CustomClassificationModelARN: !Ref Pattern2CustomClassificationModelARN
        CustomExtractionModelARN: !Ref Pattern2CustomExtractionModelARN

  PATTERN3STACK:
    Type: AWS::CloudFormation::Stack
    Condition: IsPattern3
    Properties:
      # yamllint disable rule:line-length
      TemplateURL: ./patterns/pattern-3/.aws-sam/packaged.yaml
      Parameters:
        StackName: !Ref AWS::StackName
        InputBucket: !Ref InputBucket
        WorkingBucket: !Ref WorkingBucket
        OutputBucket: !Ref OutputBucket
        TrackingTable: !Ref TrackingTable
        CustomerManagedEncryptionKeyArn: !GetAtt CustomerManagedEncryptionKey.Arn
        LogRetentionDays: !Ref LogRetentionDays
        ExecutionTimeThresholdMs: !Ref ExecutionTimeThresholdMs
        BDAProjectArn: !Ref Pattern3BDAProjectArn

  # Main stack resources

  CustomerManagedEncryptionKey:
    Type: AWS::KMS::Key
    Properties:
      Description: KMS key for DynamoDB encryption
      EnableKeyRotation: true
      KeyPolicy:
        Version: "2012-10-17"
        Statement:
          - Sid: Allow lambda to access the Keys
            Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action:
              - kms:*
            Resource: "*"
          - Sid: Allow DynamoDB to use the key
            Effect: Allow
            Principal:
              Service: dynamodb.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: "*"

  CustomerManagedEncryptionKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub "alias/${AWS::StackName}-customer-encryption-key"
      TargetKeyId: !Ref CustomerManagedEncryptionKey

  LoggingBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: RetainExceptOnCreate
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldLogs
            Status: Enabled
            ExpirationInDays: 90
            Prefix: "" # Applies to all objects in the bucket
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7

  LoggingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref LoggingBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: S3ServerAccessLogsPolicy
            Effect: Allow
            Principal:
              Service: logging.s3.amazonaws.com
            Action:
              - s3:PutObject
            Resource: !Sub "${LoggingBucket.Arn}/*"
            Condition:
              StringEquals:
                "aws:SourceAccount": !Ref "AWS::AccountId"

  InputBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: RetainExceptOnCreate
    Properties:
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !Ref CustomerManagedEncryptionKey
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: input-bucket-logs/
      LifecycleConfiguration:
        Rules:
          - Id: DeleteAfterNDays
            Status: Enabled
            ExpirationInDays: !Ref DataRetentionInDays
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1

  WorkingBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: RetainExceptOnCreate 
    Properties:
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !Ref CustomerManagedEncryptionKey
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: working-bucket-logs/
      LifecycleConfiguration:
        Rules:
          - Id: DeleteAfterNDays
            Status: Enabled
            ExpirationInDays: 30
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1

  OutputBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: RetainExceptOnCreate 
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !Ref CustomerManagedEncryptionKey
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: output-bucket-logs/
      LifecycleConfiguration:
        Rules:
          - Id: DeleteAfterNDays
            Status: Enabled
            ExpirationInDays: !Ref DataRetentionInDays
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1

  WebUIBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: RetainExceptOnCreate 
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      VersioningConfiguration:
        Status: Enabled
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: working-bucket-logs/

  TrackingTable:
    Type: AWS::DynamoDB::Table
    Properties:
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: PK
          AttributeType: S
        - AttributeName: SK
          AttributeType: S
      KeySchema:
        - AttributeName: PK
          KeyType: HASH
        - AttributeName: SK
          KeyType: RANGE
      TimeToLiveSpecification:
        AttributeName: expires_after
        Enabled: false
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref CustomerManagedEncryptionKey

  ConcurrencyTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: counter_id
          AttributeType: S
      KeySchema:
        - AttributeName: counter_id
          KeyType: HASH
      SSESpecification:
        SSEEnabled: true
        SSEType: KMS
        KMSMasterKeyId: !Ref CustomerManagedEncryptionKey

  InitializeConcurrencyTableLambda:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      Runtime: python3.11
      Timeout: 30
      InlineCode: |
        import boto3
        import cfnresponse
        import logging
        from botocore.exceptions import ClientError
        import os

        # Initialize logging
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)

        # DynamoDB resource
        dynamodb = boto3.resource('dynamodb')
        CONCURRENCY_TABLE = os.environ.get('CONCURRENCY_TABLE')
        concurrency_table = dynamodb.Table(CONCURRENCY_TABLE)

        COUNTER_ID = "workflow_counter"

        def handler(event, context):
            logger.info(f"Event received: {event}")
            try:
                # Handle CloudFormation CREATE events
                if event['RequestType'] == 'Create':
                    concurrency_table.put_item(
                        Item={
                            'counter_id': COUNTER_ID,
                            'active_count': 0
                        },
                        ConditionExpression='attribute_not_exists(counter_id)'
                    )
                    logger.info("Counter initialized")

                elif event['RequestType'] == 'Delete':
                    # Handle CloudFormation DELETE events
                    concurrency_table.delete_item(
                        Key={
                            'counter_id': COUNTER_ID
                        }
                    )
                    logger.info("Counter deleted")

                # Send a success response to CloudFormation
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

            except ClientError as e:
                logger.error(f"Error in DynamoDB operation: {e}")
                # Send a failure response to CloudFormation
                cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})
                raise

            except Exception as e:
                logger.error(f"Unexpected error: {e}")
                # Send a failure response to CloudFormation
                cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})
                raise
      Environment:
        Variables:
          CONCURRENCY_TABLE: !Ref ConcurrencyTable
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref ConcurrencyTable
        - Statement:
            - Effect: Allow
              Action:
                - kms:Encrypt
                - kms:Decrypt
                - kms:ReEncrypt*
                - kms:GenerateDataKey*
                - kms:DescribeKey
              Resource: !GetAtt CustomerManagedEncryptionKey.Arn

  InitializeConcurrencyTableCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt InitializeConcurrencyTableLambda.Arn
      TableName: !Ref ConcurrencyTable

  DocumentQueueDLQ:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId: !Ref CustomerManagedEncryptionKey
      VisibilityTimeout: 30
      MessageRetentionPeriod: 345600 # 4 days

  DocumentQueue:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId: !Ref CustomerManagedEncryptionKey
      VisibilityTimeout: 30
      MessageRetentionPeriod: 86400 # 1 day
      RedrivePolicy:
        maxReceiveCount: 1000 # should retry up to 8hrs (1000 * 30 sec visibility) before moving to DLQ
        deadLetterTargetArn: !GetAtt DocumentQueueDLQ.Arn

  QueueSenderDLQ:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId: !Ref CustomerManagedEncryptionKey
      VisibilityTimeout: 30
      MessageRetentionPeriod: 345600 # 4 days

  QueueSender:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/lambda/queue_sender/
      Handler: index.handler
      Runtime: python3.11
      Timeout: 30
      DeadLetterQueue:
        Type: SQS
        TargetArn: !GetAtt QueueSenderDLQ.Arn
      LoggingConfig:
        LogGroup: !Ref QueueSenderLogGroup
      Environment:
        Variables:
          QUEUE_URL: !Ref DocumentQueue
          APPSYNC_API_URL: !GetAtt GraphQLApi.GraphQLUrl
          DATA_RETENTION_IN_DAYS: !Ref DataRetentionInDays
      Policies:
        - SQSSendMessagePolicy:
            QueueName: !GetAtt DocumentQueue.QueueName
        - Statement:
            - Effect: Allow
              Action:
                - appsync:GraphQL
              Resource:
                - !Sub "${GraphQLApi.Arn}/types/Mutation/*"
            - Effect: Allow
              Action:
                - kms:Encrypt
                - kms:Decrypt
                - kms:ReEncrypt*
                - kms:GenerateDataKey*
                - kms:DescribeKey
              Resource: !GetAtt CustomerManagedEncryptionKey.Arn
      Events:
        S3Event:
          Type: CloudWatchEvent
          Properties:
            Pattern:
              source:
                - aws.s3
              detail-type:
                - "Object Created"
              detail:
                bucket:
                  name:
                    - !Ref InputBucket

  QueueSenderLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/queue-sender"
      RetentionInDays: !Ref LogRetentionDays

  QueueProcessor:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/lambda/queue_processor/
      Handler: index.handler
      Runtime: python3.11
      Timeout: 30
      LoggingConfig:
        LogGroup: !Ref QueueProcessorLogGroup
      Environment:
        Variables:
          STATE_MACHINE_ARN: !If
            - IsPattern1
            - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
            - !If
              - IsPattern2
              - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
              - !GetAtt PATTERN3STACK.Outputs.StateMachineArn
          APPSYNC_API_URL: !GetAtt GraphQLApi.GraphQLUrl
          CONCURRENCY_TABLE: !Ref ConcurrencyTable
          MAX_CONCURRENT: !Ref MaxConcurrentWorkflows
      Policies:
        - SQSPollerPolicy:
            QueueName: !GetAtt DocumentQueue.QueueName
        - StepFunctionsExecutionPolicy:
            StateMachineName: !If
              - IsPattern1
              - !GetAtt PATTERN1STACK.Outputs.StateMachineName
              - !If
                - IsPattern2
                - !GetAtt PATTERN2STACK.Outputs.StateMachineName
                - !GetAtt PATTERN3STACK.Outputs.StateMachineName
        - DynamoDBCrudPolicy:
            TableName: !Ref TrackingTable
        - DynamoDBCrudPolicy:
            TableName: !Ref ConcurrencyTable
        - Statement:
            - Effect: Allow
              Action:
                - appsync:GraphQL
              Resource:
                - !Sub "${GraphQLApi.Arn}/types/Mutation/*"
            - Effect: Allow
              Action:
                - kms:Encrypt
                - kms:Decrypt
                - kms:ReEncrypt*
                - kms:GenerateDataKey*
                - kms:DescribeKey
              Resource: !GetAtt CustomerManagedEncryptionKey.Arn
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt DocumentQueue.Arn
            BatchSize: 50 # Process up to 50 messages at once
            MaximumBatchingWindowInSeconds: 1 # Wait max 1 second to fill batch
            FunctionResponseTypes:
              - ReportBatchItemFailures

  QueueProcessorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/queue-processor"
      RetentionInDays: !Ref LogRetentionDays

  WorkflowTrackerDLQ:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId: !Ref CustomerManagedEncryptionKey
      VisibilityTimeout: 30
      MessageRetentionPeriod: 345600 # 4 days

  WorkflowTracker:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/lambda/workflow_tracker/
      Handler: index.handler
      Runtime: python3.11
      Timeout: 30
      DeadLetterQueue:
        Type: SQS
        TargetArn: !GetAtt WorkflowTrackerDLQ.Arn
      LoggingConfig:
        LogGroup: !Ref WorkflowTrackerLogGroup
      Environment:
        Variables:
          CONCURRENCY_TABLE: !Ref ConcurrencyTable
          METRIC_NAMESPACE: !Ref AWS::StackName
          APPSYNC_API_URL: !GetAtt GraphQLApi.GraphQLUrl
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref TrackingTable
        - DynamoDBCrudPolicy:
            TableName: !Ref ConcurrencyTable
        - Statement:
            - Effect: Allow
              Action:
                - cloudwatch:PutMetricData
              Resource: "*"
            - Effect: Allow
              Action:
                - appsync:GraphQL
              Resource:
                - !Sub "${GraphQLApi.Arn}/types/Mutation/*"
            - Effect: Allow
              Action:
                - kms:Encrypt
                - kms:Decrypt
                - kms:ReEncrypt*
                - kms:GenerateDataKey*
                - kms:DescribeKey
              Resource: !GetAtt CustomerManagedEncryptionKey.Arn

  WorkflowTrackerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/workflow-tracker"
      RetentionInDays: !Ref LogRetentionDays

  WorkflowStateChangeRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.states
        detail-type:
          - Step Functions Execution Status Change
        detail:
          stateMachineArn:
            - !If
              - IsPattern1
              - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
              - !If
                - IsPattern2
                - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
                - !GetAtt PATTERN3STACK.Outputs.StateMachineArn
          status:
            - FAILED
            - TIMED_OUT
            - ABORTED
            - SUCCEEDED
      State: ENABLED
      Targets:
        - Arn: !GetAtt WorkflowTracker.Arn
          Id: TrackWorkflowCompletion
          RetryPolicy:
            MaximumRetryAttempts: 3

  WorkflowTrackerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WorkflowTracker
      Principal: events.amazonaws.com
      SourceArn: !GetAtt WorkflowStateChangeRule.Arn

  AlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Workflow Alerts

  WorkflowErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: !Sub "Alert when workflow errors exceed ${ErrorThreshold} in 5 minutes"
      MetricName: ExecutionsFailedCount
      Namespace: AWS/States
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: !Ref ErrorThreshold
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: StateMachineArn
          Value: !If
            - IsPattern1
            - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
            - !If
              - IsPattern2
              - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
              - !GetAtt PATTERN3STACK.Outputs.StateMachineArn
      AlarmActions:
        - !Ref AlertsTopic

  SlowExecutionsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: !Sub "Alert when average execution time exceeds ${ExecutionTimeThresholdMs} milliseconds"
      MetricName: ExecutionTime
      Namespace: AWS/States
      Statistic: Average
      Period: 300
      EvaluationPeriods: 1
      Threshold: !Ref ExecutionTimeThresholdMs
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: StateMachineArn
          Value: !If
            - IsPattern1
            - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
            - !If
              - IsPattern2
              - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
              - !GetAtt PATTERN3STACK.Outputs.StateMachineArn
      AlarmActions:
        - !Ref AlertsTopic

  MainTemplateSubsetDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub "${AWS::StackName}-${AWS::Region}-MainTemplate-Subset"
      DashboardBody: !Sub
        - |
          {
            "widgets": [
              {
                "type": "metric",
                "x": 0,
                "y": 0,
                "width": 8,
                "height": 6,
                "properties": {
                  "metrics": [
                    [
                      "${AWS::StackName}",
                      "QueueLatencyMilliseconds",
                      {
                        "stat": "Average"
                      }
                    ],
                    [
                      ".",
                      "QueueLatencyMilliseconds",
                      {
                        "stat": "p90"
                      }
                    ],
                    [
                      ".",
                      "QueueLatencyMilliseconds",
                      {
                        "stat": "Maximum"
                      }
                    ]
                  ],
                  "region": "${AWS::Region}",
                  "title": "Queue Latency",
                  "period": 300,
                  "view": "timeSeries",
                  "annotations": {
                    "horizontal": [
                      {
                        "value": ${ExecutionTimeThresholdMs
                        },
                        "label": "Threshold (${ExecutionTimeThresholdMs}ms)",
                        "color": "#ff0000"
                      }
                    ]
                  }
                }
              },
              {
                "type": "metric",
                "x": 8,
                "y": 0,
                "width": 8,
                "height": 6,
                "properties": {
                  "metrics": [
                    [
                      "${AWS::StackName}",
                      "WorkflowLatencyMilliseconds",
                      {
                        "stat": "Average"
                      }
                    ],
                    [
                      ".",
                      "WorkflowLatencyMilliseconds",
                      {
                        "stat": "p90"
                      }
                    ],
                    [
                      ".",
                      "WorkflowLatencyMilliseconds",
                      {
                        "stat": "Maximum"
                      }
                    ]
                  ],
                  "region": "${AWS::Region}",
                  "title": "Workflow Latency",
                  "period": 300,
                  "view": "timeSeries",
                  "annotations": {
                    "horizontal": [
                      {
                        "value": ${ExecutionTimeThresholdMs
                        },
                        "label": "Threshold (${ExecutionTimeThresholdMs}ms)",
                        "color": "#ff0000"
                      }
                    ]
                  }
                }
              },
              {
                "type": "metric",
                "x": 16,
                "y": 0,
                "width": 8,
                "height": 6,
                "properties": {
                  "metrics": [
                    [
                      "${AWS::StackName}",
                      "TotalLatencyMilliseconds",
                      {
                        "stat": "Average"
                      }
                    ],
                    [
                      ".",
                      "TotalLatencyMilliseconds",
                      {
                        "stat": "p90"
                      }
                    ],
                    [
                      ".",
                      "TotalLatencyMilliseconds",
                      {
                        "stat": "Maximum"
                      }
                    ]
                  ],
                  "region": "${AWS::Region}",
                  "title": "Total Processing Latency",
                  "period": 300,
                  "view": "timeSeries",
                  "annotations": {
                    "horizontal": [
                      {
                        "value": ${ExecutionTimeThresholdMs
                        },
                        "label": "Threshold (${ExecutionTimeThresholdMs}ms)",
                        "color": "#ff0000"
                      }
                    ]
                  }
                }
              },
              {
                "type": "metric",
                "x": 0,
                "y": 6,
                "width": 8,
                "height": 6,
                "properties": {
                  "metrics": [
                    [
                      {
                        "expression": "m1/PERIOD(m1)*60",
                        "label": "Messages Received per Minute",
                        "id": "e1"
                      }
                    ],
                    [
                      {
                        "expression": "m2/PERIOD(m2)*60",
                        "label": "Messages Deleted per Minute",
                        "id": "e2"
                      }
                    ],
                    [
                      "AWS/SQS",
                      "NumberOfMessagesReceived",
                      "QueueName",
                      "${DocumentQueue.QueueName}",
                      {
                        "id": "m1",
                        "stat": "Sum",
                        "visible": false
                      }
                    ],
                    [
                      ".",
                      "NumberOfMessagesDeleted",
                      ".",
                      ".",
                      {
                        "id": "m2",
                        "stat": "Sum",
                        "visible": false
                      }
                    ]
                  ],
                  "region": "${AWS::Region}",
                  "title": "SQS Queue Metrics (per Minute)",
                  "view": "timeSeries",
                  "period": 60,
                  "yAxis": {
                    "left": {
                      "label": "Count per Minute"
                    }
                  }
                }
              },
              {
                "type": "metric",
                "x": 8,
                "y": 6,
                "width": 8,
                "height": 6,
                "properties": {
                  "metrics": [
                    [
                      {
                        "expression": "m1/PERIOD(m1)*60",
                        "label": "Started per Minute",
                        "id": "e1"
                      }
                    ],
                    [
                      {
                        "expression": "m2/PERIOD(m2)*60",
                        "label": "Succeeded per Minute",
                        "id": "e2"
                      }
                    ],
                    [
                      {
                        "expression": "m3/PERIOD(m3)*60",
                        "label": "Failed per Minute",
                        "id": "e3"
                      }
                    ],
                    [
                      "AWS/States",
                      "ExecutionsStarted",
                      "StateMachineArn",
                      "${StateMachineArn}",
                      {
                        "id": "m1",
                        "stat": "Sum",
                        "visible": false
                      }
                    ],
                    [
                      ".",
                      "ExecutionsSucceeded",
                      ".",
                      ".",
                      {
                        "id": "m2",
                        "stat": "Sum",
                        "visible": false
                      }
                    ],
                    [
                      ".",
                      "ExecutionsFailed",
                      ".",
                      ".",
                      {
                        "id": "m3",
                        "stat": "Sum",
                        "visible": false
                      }
                    ]
                  ],
                  "region": "${AWS::Region}",
                  "title": "Workflow Executions (per Minute)",
                  "view": "timeSeries",
                  "period": 60,
                  "yAxis": {
                    "left": {
                      "label": "Count per Minute"
                    }
                  }
                }
              },
              {
                "type": "log",
                "x": 18,
                "y": 6,
                "width": 8,
                "height": 6,
                "properties": {
                  "query": "SOURCE '${WorkflowTrackerLogGroup}' | fields @timestamp, @message | filter @message like /Publishing latency metrics/ | parse @message 'total: *ms' as totalTime |  filter totalTime > ${ExecutionTimeThresholdMs} |  stats count(*) as high_latency_count by bin(1m)",
                  "region": "${AWS::Region}",
                  "title": "Count of Workflow Executions over latency threshold (${ExecutionTimeThresholdMs}ms)",
                  "stacked": false,
                  "view": "timeSeries"
                }
              },
              {
                "type": "log",
                "x": 0,
                "y": 12,
                "width": 24,
                "height": 6,
                "properties": {
                  "query": "SOURCE '${StateMachineLogGroup}' | fields @timestamp, @message | filter @message like /ExecutionFailed/ or @message like /TimedOut/ | parse @message /execution: (?<execution_arn>[^ ]*)/ | parse @message /error: (?<error>[^\"]*)/| sort @timestamp desc | limit 20",
                  "region": "${AWS::Region}",
                  "title": "Step Functions Executions Failed",
                  "view": "table"
                }
              },
              {
                "type": "log",
                "x": 0,
                "y": 18,
                "width": 12,
                "height": 6,
                "properties": {
                  "query": "SOURCE '${QueueSenderLogGroup}' | fields @timestamp, @logStream, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 20",
                  "region": "${AWS::Region}",
                  "title": "Queue Sender Lambda Errors",
                  "view": "table"
                }
              },
              {
                "type": "log",
                "x": 12,
                "y": 18,
                "width": 12,
                "height": 6,
                "properties": {
                  "query": "SOURCE '${QueueProcessorLogGroup}' | fields @timestamp, @logStream, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 20",
                  "region": "${AWS::Region}",
                  "title": "Queue Processor Lambda Errors",
                  "view": "table"
                }
              },
              {
                "type": "log",
                "x": 0,
                "y": 24,
                "width": 12,
                "height": 6,
                "properties": {
                  "query": "SOURCE '${WorkflowTrackerLogGroup}' | fields @timestamp, @logStream, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 20",
                  "region": "${AWS::Region}",
                  "title": "Workflow Tracker Lambda Errors",
                  "view": "table"
                }
              },
              {
                "type": "log",
                "x": 12,
                "y": 24,
                "width": 12,
                "height": 6,
                "properties": {
                  "query": "SOURCE '${LookupFunctionLogGroup}' | fields @timestamp, @logStream, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 20",
                  "region": "${AWS::Region}",
                  "title": "Lookup Lambda Errors",
                  "view": "table"
                }
              }
            ]
          }
        - StateMachineArn: !If
            - IsPattern1
            - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
            - !If
              - IsPattern2
              - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
              - !GetAtt PATTERN3STACK.Outputs.StateMachineArn
          StateMachineLogGroup: !If
            - IsPattern1
            - !GetAtt PATTERN1STACK.Outputs.StateMachineLogGroup
            - !If
              - IsPattern2
              - !GetAtt PATTERN2STACK.Outputs.StateMachineLogGroup
              - !GetAtt PATTERN3STACK.Outputs.StateMachineLogGroup

  DashboardMergerFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/lambda/dashboard_merger
      Handler: index.handler
      Runtime: python3.11
      Timeout: 60
      MemorySize: 128
      Environment:
        Variables:
          STACK_NAME: !Ref AWS::StackName
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - cloudwatch:GetDashboard
                - cloudwatch:ListDashboards
                - cloudwatch:PutDashboard
                - cloudwatch:DeleteDashboards
              Resource: "*"

  MergedDashboard:
    Type: Custom::DashboardMerger
    Properties:
      ServiceToken: !GetAtt DashboardMergerFunction.Arn
      Dashboard1Name: !Ref MainTemplateSubsetDashboard
      Dashboard2Name: !If
        - IsPattern1
        - !GetAtt PATTERN1STACK.Outputs.DashboardName
        - !If
          - IsPattern2
          - !GetAtt PATTERN2STACK.Outputs.DashboardName
          - !GetAtt PATTERN3STACK.Outputs.DashboardName
      MergedDashboardName: !Sub "${AWS::StackName}-${AWS::Region}"
      ChangeToForceUpdate: <HASH> # Source code hash set by publish script

  LookupFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/lambda/lookup_function/
      Handler: index.handler
      Runtime: python3.11
      Timeout: 30
      LoggingConfig:
        LogGroup: !Ref LookupFunctionLogGroup
      Environment:
        Variables:
          TRACKING_TABLE: !Ref TrackingTable
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Ref TrackingTable
        - Statement:
            - Effect: Allow
              Action:
                - states:DescribeExecution
                - states:GetExecutionHistory
              Resource:
                - !Sub
                  - "arn:aws:states:${AWS::Region}:${AWS::AccountId}:execution:${StateMachineName}*"
                  - StateMachineName: !If
                      - IsPattern1
                      - !GetAtt PATTERN1STACK.Outputs.StateMachineName
                      - !If
                        - IsPattern2
                        - !GetAtt PATTERN2STACK.Outputs.StateMachineName
                        - !GetAtt PATTERN3STACK.Outputs.StateMachineName
            - Effect: Allow
              Action:
                - kms:Encrypt
                - kms:Decrypt
                - kms:ReEncrypt*
                - kms:GenerateDataKey*
                - kms:DescribeKey
              Resource: !GetAtt CustomerManagedEncryptionKey.Arn

  LookupFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/lookup"
      RetentionInDays: !Ref LogRetentionDays

  # Initialise SettingsParameter as empty (so it never gets replaced)
  # and use Custom Resource UpdateSettingsFunction to add/update values
  SettingsParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Type: String
      Name: !Sub "${AWS::StackName}-Settings"
      Value: "{}"

  UpdateSettingsFunctionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: "sts:AssumeRole"
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: updateSSMStore
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Resource:
                  - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${SettingsParameter}"

  UpdateSettingsFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Role: !GetAtt UpdateSettingsFunctionRole.Arn
      Handler: index.handler
      Runtime: python3.12
      Timeout: 900
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          ssm = boto3.client('ssm')
          def updateSSMParameter(props):
            parameterName = props['SettingsName']
            parameterValues = props['SettingsKeyValuePairs']
            response = ssm.get_parameter(Name=parameterName)
            settingsJSON = response['Parameter']['Value']
            settings = json.loads(settingsJSON)
            print(f"Existing settings: {settings}")
            for key, value in parameterValues.items():
              settings[key] = value
            print(f"Updated settings: {settings}")
            newSettingsJSON = json.dumps(settings)
            ssm.put_parameter(Name=parameterName, Value=newSettingsJSON, Overwrite=True)
                        
          def handler(event, context):        
            print(json.dumps(event))
            status = cfnresponse.SUCCESS
            responseData = {}
            reason = "Success"
            props = event["ResourceProperties"]
            if event['RequestType'] != 'Delete':
              try:
                updateSSMParameter(props)
              except Exception as e:
                print(e)
                reason = f"Exception thrown: {e}"
                status = cfnresponse.FAILED              
            cfnresponse.send(event, context, status, responseData, reason=reason)
      LoggingConfig:
        LogGroup: !Ref UpdateSettingsFunctionLogGroup

  UpdateSettingsFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref LogRetentionDays

  UpdateSettingsValues:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt UpdateSettingsFunction.Arn
      SettingsName: !Ref SettingsParameter
      SettingsKeyValuePairs:
        # to be extended
        ShouldUseDocumentKnowledgeBase: False
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete

  # Cognito resources

  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub ${AWS::StackName}-users
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: !If
          - ShouldAllowSignUpEmailDomain
          - false
          - true
        InviteMessageTemplate:
          EmailSubject: Welcome to GenAI-IDP!
          EmailMessage: !Sub |-
            <p>Hello {username},</p>
            <p>Welcome to the AWS GenAI-IDP Solution! Your temporary password is: <strong>{####}</strong></p>
            <p>When the CloudFormation stack is COMPLETE, use the link below to log in and set your permanent password.
            <p>     https://${CloudFrontDistribution.DomainName}/
            <p>Thanks,</p>
            <p>GenAI-IDP</p>
      AutoVerifiedAttributes:
        - email
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT
      EmailVerificationMessage: >-
        Please verify your email to complete account registration. Confirmation Code
        {####}.
      EmailVerificationSubject: >-
        Account Verification
      LambdaConfig: !If
        - ShouldAllowSignUpEmailDomain
        - PreAuthentication: !GetAtt CognitoUserPoolEmailDomainVerifyFunction.Arn
          PreSignUp: !GetAtt CognitoUserPoolEmailDomainVerifyFunction.Arn
        - !Ref AWS::NoValue
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: false
          Required: true
      UsernameConfiguration:
        CaseSensitive: false

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub "${AWS::StackName}-Client"
      AllowedOAuthFlows:
        - code
      AllowedOAuthFlowsUserPoolClient: true
      AllowedOAuthScopes:
        - openid
        - email
        - phone
        - profile
      CallbackURLs:
        - http://localhost:3000
        - http://localhost:5173
        - https://bmpfinegchjaiocjnfjfcgeohdiblomp.chromiumapp.org/
      AccessTokenValidity: 1
      EnableTokenRevocation: true
      ExplicitAuthFlows:
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      GenerateSecret: false
      IdTokenValidity: 1
      PreventUserExistenceErrors: ENABLED
      ReadAttributes:
        - email
        - email_verified
        - preferred_username
      RefreshTokenValidity: 30
      SupportedIdentityProviders:
        - COGNITO
      UserPoolId: !Ref UserPool

  GetDomainLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  GetDomainLambda:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: Returns the lowercase version of a string
      MemorySize: 256
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt GetDomainLambdaRole.Arn
      Timeout: 30
      Code:
        ZipFile: |
          import cfnresponse
          import time
          def lambda_handler(event, context):                                                    
              output = event['ResourceProperties'].get('InputString', '').lower()
              output = f"{output}-{time.time_ns()}" # make unique
              responseData = {'OutputString': output}                                            
              cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
      LoggingConfig:
        LogGroup: !Ref GetDomainLambdaLogGroup

  GetDomainLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref LogRetentionDays

  GetDomain:
    Type: Custom::GetDomain
    Properties:
      ServiceToken: !GetAtt GetDomainLambda.Arn
      InputString: !Ref AWS::StackName

  UserPoolDomain:
    Type: "AWS::Cognito::UserPoolDomain"
    Properties:
      Domain: !GetAtt GetDomain.OutputString
      UserPoolId: !Ref UserPool

  IdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: !Sub "${AWS::StackName}-IdentityPool"
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders:
        - ClientId: !Ref UserPoolClient
          ProviderName: !GetAtt UserPool.ProviderName

  CognitoIdentityPoolSetRole:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: !Ref IdentityPool
      Roles:
        authenticated: !GetAtt CognitoAuthorizedRole.Arn

  CognitoAuthorizedRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
            Action:
              - sts:AssumeRoleWithWebIdentity
            Condition:
              StringEquals:
                "cognito-identity.amazonaws.com:aud": !Ref IdentityPool
              "ForAnyValue:StringLike":
                "cognito-identity.amazonaws.com:amr": authenticated
      Policies:
        - PolicyName: accessS3RecordingsPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "s3:GetObject"
                Resource:
                  - !Sub "arn:aws:s3:::${InputBucket}"
                  - !Sub "arn:aws:s3:::${InputBucket}/*"
                  - !Sub "arn:aws:s3:::${OutputBucket}"
                  - !Sub "arn:aws:s3:::${OutputBucket}/*"
        - PolicyName: accessParameterStore
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - "ssm:GetParameter"
                Resource:
                  - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${SettingsParameter}"

  AdminUser:
    Type: AWS::Cognito::UserPoolUser
    DependsOn: CognitoUserPoolEmailDomainVerifyPermissionReady
    Properties:
      DesiredDeliveryMediums:
        - EMAIL
      UserAttributes:
        - Name: email
          Value: !Ref AdminEmail
      Username: !Ref AdminEmail
      UserPoolId: !Ref UserPool

  # Create conditional dependency on CognitoUserPoolEmailDomainVerifyPermission
  CognitoUserPoolEmailDomainVerifyPermissionReady:
    Type: AWS::CloudFormation::WaitConditionHandle
    Metadata:
      ConditionalDependency:
        !If [
          ShouldAllowSignUpEmailDomain,
          !Ref CognitoUserPoolEmailDomainVerifyPermission,
          "",
        ]

  AdminGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      Description: Administrators
      GroupName: Admin
      Precedence: 0
      UserPoolId: !Ref UserPool

  AdminUserToGroupAttachment:
    Type: AWS::Cognito::UserPoolUserToGroupAttachment
    Properties:
      GroupName: !Ref AdminGroup
      Username: !Ref AdminUser
      UserPoolId: !Ref UserPool

  CognitoUserPoolEmailDomainVerifyFunction:
    Type: AWS::Serverless::Function
    Condition: ShouldAllowSignUpEmailDomain
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.11
      Timeout: 10
      Environment:
        Variables:
          ALLOWED_SIGNUP_EMAIL_DOMAINS: !Ref AllowedSignUpEmailDomain
      InlineCode: |
        import os
        import boto3
        import json

        def lambda_handler(event, context):
            print(json.dumps(event))

            allowed_domains = [
                domain.strip() 
                for domain in os.environ.get('ALLOWED_SIGNUP_EMAIL_DOMAINS', '').split(',')
            ]

            user_attributes = event.get('request', {}).get('userAttributes', {})
            email = user_attributes.get('email')

            if not email or '@' not in email:
                raise ValueError('Username does not exist or invalid email address')

            email_domain = email.split('@')[1]

            if not email_domain or not allowed_domains:
                raise ValueError('Server error - invalid configuration')

            if email_domain not in allowed_domains:
                raise ValueError('Invalid email address domain')

            return event
      LoggingConfig:
        LogGroup:
          Fn::Sub: /${AWS::StackName}/lambda/CognitoUserPoolEmailDomainVerifyFunction
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: Customer can use VPC if desired
          - id: W92
            reason: Customer can choose reserved concurrency based on their requirement.
    DependsOn:
      - CognitoUserPoolEmailDomainVerifyFunctionLogGroup

  CognitoUserPoolEmailDomainVerifyFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/${AWS::StackName}/lambda/CognitoUserPoolEmailDomainVerifyFunction"
      RetentionInDays: !Ref LogRetentionDays

  CognitoUserPoolEmailDomainVerifyPermission:
    Type: AWS::Lambda::Permission
    Condition: ShouldAllowSignUpEmailDomain
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref CognitoUserPoolEmailDomainVerifyFunction
      Principal: cognito-idp.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !GetAtt UserPool.Arn

  # AppSync API

  AppSyncCwlRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - appsync.amazonaws.com

  GraphQLApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub ${AWS::StackName}-api
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      UserPoolConfig:
        UserPoolId: !Ref UserPool
        AwsRegion: !Ref AWS::Region
        DefaultAction: ALLOW
      AdditionalAuthenticationProviders:
        - AuthenticationType: AWS_IAM
      LogConfig:
        CloudWatchLogsRoleArn: !GetAtt AppSyncCwlRole.Arn
        ExcludeVerboseContent: false
        FieldLogLevel: ALL

  GraphQLApiLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/appsync/apis/${GraphQLApi.ApiId}"
      RetentionInDays: !Ref LogRetentionDays

  GraphQLSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      DefinitionS3Location: ./src/api/schema.graphql

  # DynamoDB Data Source
  TrackingTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: TrackingTableDataSource
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Ref TrackingTable
        AwsRegion: !Ref AWS::Region

  # AppSync Service Role
  AppSyncServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Sub arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${TrackingTable}
              - Effect: Allow
                Action:
                  - kms:Encrypt
                  - kms:Decrypt
                  - kms:ReEncrypt*
                  - kms:GenerateDataKey*
                  - kms:DescribeKey
                Resource: !GetAtt CustomerManagedEncryptionKey.Arn

# AppSync Resolvers
  CreateDocumentResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: createDocument
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      # This resolver creates two items in the table
      # - the doc item (PK = doc#<object_key>) - containing all doc attributes
      # - the list item (PK = list#<date>#s<shardid>) - which associates a time shard to the doc identified by the SK value
      #    - this is used to list documents without resorting to DynamoDB scans 
      # Because we use !Sub to substitute TrackingTable, we must escape other occurences of ${x} like ${!x}
      RequestMappingTemplate: !Sub |
        #set( $PK = "doc#${!ctx.args.input.object_key}" )

        #set( $shardsInDay = 6 )
        #set( $shardDivider = 24 / $shardsInDay )
        #set( $Integer = 0 )
        #set( $now = $ctx.args.input.queued_time )
        #set( $date = $now.substring(0, 10) )
        #set( $hourString = $now.substring(11, 13) )
        #set( $hour = $Integer.parseInt($hourString) )
        #set( $hourShard = $hour / $shardDivider )
        #set( $shardPad = $date.format("%02d", $hourShard) )
        #set( $listPk = "list#${!date}#s#${!shardPad}" )
        #set( $listSk = "ts#${!now}#id#${!ctx.args.input.object_key}" )

        {
          "version" : "2018-05-29",
          "operation" : "TransactWriteItems",
          "transactItems": [
            {
              "table": "${TrackingTable}",
              "operation": "PutItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($PK),
                "SK": $util.dynamodb.toDynamoDBJson("none"),
              },
              "attributeValues": $util.dynamodb.toMapValuesJson($ctx.args.input),
            },
            {
              "table": "${TrackingTable}",
              "operation": "PutItem",
              "key" : {
                "PK": $util.dynamodb.toDynamoDBJson($listPk),
                "SK": $util.dynamodb.toDynamoDBJson($listSk),
              },
              "attributeValues": {
                "object_key": $util.dynamodb.toDynamoDBJson($ctx.args.input.object_key),
                "queued_time": $util.dynamodb.toDynamoDBJson($ctx.args.input.queued_time),
                "expires_after": $util.dynamodb.toDynamoDBJson($ctx.args.input.expires_after),
              },
            },
          ],
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        $util.toJson($ctx.args.input.object_key)

  UpdateDocumentResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateDocument
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      RequestMappingTemplate: |-
        #set( $PK = "doc#${ctx.args.input.object_key}" )
        #set( $expNames = {} )
        #set( $expValues = {} )
        #set( $expSet = {} )
        ## Iterate through each argument with values and update expression variables **
        #foreach( $entry in $ctx.args.input.entrySet() )
            ## skip empty values **
            #if( !$util.isNullOrBlank($entry.value)  )
                $util.qr( $expSet.put("#${entry.key}", ":${entry.key}") )
                $util.qr( $expNames.put("#${entry.key}", "${entry.key}") )
                $util.qr( $expValues.put(":${entry.key}", $util.dynamodb.toDynamoDB($entry.value)) )
            #end
        #end
        ## Start building the update expression, starting with attributes we're going to SET **
        #set( $expression = "" )
        #if( !${expSet.isEmpty()} )
            #set( $expression = "SET" )
            #foreach( $entry in $expSet.entrySet() )
                #set( $expression = "${expression} ${entry.key} = ${entry.value}" )
                #if ( $foreach.hasNext )
                    #set( $expression = "${expression}," )
                #end
            #end
        #end
        {
            "version" : "2018-05-29",
            "operation" : "UpdateItem",
            "key" : {
              "PK": $util.dynamodb.toDynamoDBJson($PK),
              "SK": $util.dynamodb.toDynamoDBJson("none"),
            },
            "update" : {
                "expression": "$expression"
                #if( !${expNames.isEmpty()} )
                , "expressionNames": $utils.toJson($expNames)
                #end
                #if( !${expValues.isEmpty()} )
                , "expressionValues": $utils.toJson($expValues)
                #end
            }
        }
      ResponseMappingTemplate: |
        $util.toJson($ctx.result)

  OnDocumentUpdatedResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Subscription
      FieldName: onDocumentUpdated
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version": "2018-05-29"
          "payload": $util.toJson($ctx.args)
        }
      ResponseMappingTemplate: |
        $util.toJson($ctx.result)

  GetDocumentResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getDocument
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      RequestMappingTemplate: |
        #set( $PK = "doc#${ctx.args.input.object_key}" )
        {
          "version": "2018-05-29",
          "operation": "GetItem",
          "key" : {
            "PK": $util.dynamodb.toDynamoDBJson($PK),
            "SK": $util.dynamodb.toDynamoDBJson("none"),
          }
        }
      ResponseMappingTemplate: |
        $util.toJson($ctx.result)

  ListDocumentResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: listDocuments
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2018-05-29",
            "operation": "Scan",
            "filter": {
                #if($context.arguments.startDateTime && $context.arguments.endDateTime)
                    "expression": "initial_event_time BETWEEN :startDateTime AND :endDateTime",
                    "expressionValues": {
                        ":startDateTime": { "S": "$context.arguments.startDateTime" },
                        ":endDateTime": { "S": "$context.arguments.endDateTime" }
                    }
                #elseif($context.arguments.startDateTime)
                    "expression": "initial_event_time >= :startDateTime",
                    "expressionValues": {
                        ":startDateTime": { "S": "$context.arguments.startDateTime" }
                    }
                #elseif($context.arguments.endDateTime)
                    "expression": "initial_event_time <= :endDateTime",
                    "expressionValues": {
                        ":endDateTime": { "S": "$context.arguments.endDateTime" }
                    }
                #end
            },
            #if($context.prev.result)
                "nextToken": "$context.prev.result.nextToken",
            #end
            "limit": 50,
            "consistentRead": false,
            "select": "ALL_ATTRIBUTES"
        }
      ResponseMappingTemplate: |
        {
            "Documents": $util.toJson($ctx.result.items),
            "nextToken": $util.toJson($ctx.result.nextToken)
        }

  ListDocumentDateHourResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: listDocumentsDateHour
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      RequestMappingTemplate: |
        #set( $shardsInDay = 6 )
        #set( $shardDivider = 24 / $shardsInDay )
        #set( $Integer = 0 )
        #set( $now = $util.time.nowISO8601() )
        #set( $hourNow = $Integer.parseInt($now.substring(11, 13)) )
        #set( $date = $util.defaultIfNullOrBlank($ctx.args.date, $now.substring(0, 10)) )
        #set( $hour = $util.defaultIfNull($ctx.args.hour, $hourNow) )
        #if( $hour < 0 || $hour > 23 )
          $util.error("Invalid hour parameter - value should be between 0 and 23")
        #end
        #set( $hourPad = $date.format("%02d", $hour) )
        #set( $hourShard = $hour / $shardDivider )
        #set( $shardPad = $date.format("%02d", $hourShard) )

        #set( $PK = "list#${date}#s#${shardPad}" )
        #set( $skPrefix = "ts#${date}T${hourPad}" )

        {
          "version" : "2018-05-29",
          "operation" : "Query",
          "query" : {
            "expression": "PK = :PK and begins_with(SK, :prefix)",
            "expressionValues": {
              ":PK": $util.dynamodb.toDynamoDBJson($PK),
              ":prefix": $util.dynamodb.toDynamoDBJson($skPrefix),
            },
          },
        }
      ResponseMappingTemplate: |
        {
            "Documents": $util.toJson($ctx.result.items),
            "nextToken": $util.toJson($ctx.result.nextToken)
        }

  ListDocumentDateShardResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: listDocumentsDateShard
      DataSourceName: !GetAtt TrackingTableDataSource.Name
      RequestMappingTemplate: |
        #set( $shardsInDay = 6 )
        #set( $shardDivider = 24 / $shardsInDay )
        #set( $Integer = 0 )
        #set( $now = $util.time.nowISO8601() )
        #set( $hourNow = $Integer.parseInt($now.substring(11, 13)) )
        #set( $shardNow = $hourNow / $shardDivider )
        #set( $date = $util.defaultIfNullOrBlank($ctx.args.date, $now.substring(0, 10)) )
        #set( $shard = $util.defaultIfNull($ctx.args.shard, $shardNow) )
        #if( $shard >= $shardsInDay )
          $util.error("Invalid shard parameter value - must positive and less than ${shardsInDay}")
        #end
        #set( $hourShard = $hour / $shardDivider )
        #set( $shardPad = $date.format("%02d", $shard) )

        #set( $PK = "list#${date}#s#${shardPad}" )

        {
          "version" : "2018-05-29",
          "operation" : "Query",
          "query" : {
            "expression": "PK = :PK",
            "expressionValues": {
              ":PK": $util.dynamodb.toDynamoDBJson($PK),
            }
          }
        }
      ResponseMappingTemplate: |
        {
            "Documents": $util.toJson($ctx.result.items),
            "nextToken": $util.toJson($ctx.result.nextToken)
        }


  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !GetAtt WebUIBucket.RegionalDomainName
            Id: S3Origin
            S3OriginConfig:
              OriginAccessIdentity: !Sub origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}
        Enabled: true
        DefaultRootObject: index.html
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # CachingOptimized
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # CORS-S3Origin
        CustomErrorResponses:
          - ErrorCode: 403
            ResponsePagePath: /index.html
            ResponseCode: 200
          - ErrorCode: 404
            ResponsePagePath: /index.html
            ResponseCode: 200

  CloudFrontOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub ${AWS::StackName} OAI

Outputs:
  ApplicationWebURL:
    Description: Application Web URL
    Value: !Sub "https://${CloudFrontDistribution.DomainName}/"
  S3InputBucketName:
    Description: Input S3 bucket name
    Value: !Ref InputBucket
  S3InputBucketConsoleURL:
    Description: Input S3 bucket console URL
    Value: !Sub https://s3.console.aws.amazon.com/s3/buckets/${InputBucket}
  S3OutputBucketName:
    Description: Output S3 bucket name
    Value: !Ref OutputBucket
  S3OutputBucketConsoleURL:
    Description: Output S3 bucket console URL
    Value: !Sub https://s3.console.aws.amazon.com/s3/buckets/${OutputBucket}
  S3WorkingBucketName:
    Description: Output S3 bucket name
    Value: !Ref OutputBucket
  S3WorkingBucketConsoleURL:
    Description: Working S3 bucket console URL (stores intermediate files, images and OCR data)
    Value: !Sub https://s3.console.aws.amazon.com/s3/buckets/${WorkingBucket}
  StateMachineArn:
    Description: Step Functions State machine ARN
    Value: !If
      - IsPattern1
      - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
      - !If
        - IsPattern2
        - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
        - !GetAtt PATTERN3STACK.Outputs.StateMachineArn
  StateMachineConsoleURL:
    Description: Step Functions State machine console URL
    Value: !Sub
      - https://${AWS::Region}.console.aws.amazon.com/states/home?region=${AWS::Region}#/statemachines/view/${StateMachineArn}
      - StateMachineArn: !If
          - IsPattern1
          - !GetAtt PATTERN1STACK.Outputs.StateMachineArn
          - !If
            - IsPattern2
            - !GetAtt PATTERN2STACK.Outputs.StateMachineArn
            - !GetAtt PATTERN3STACK.Outputs.StateMachineArn

  CWDashboardConsoleName:
    Description: Name of the merged CloudWatch dashboard
    Value: !GetAtt MergedDashboard.DashboardName
  CWDashboardConsoleURL:
    Description: URL of the merged CloudWatch dashboard
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${MergedDashboard.DashboardName}"
  SNSAlertsTopicARN:
    Description: SNS Topic ARN for alerts
    Value: !Ref AlertsTopic
  SNSAlertsTopicConsoleURL:
    Description: SNS Topic console URL
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/sns/v3/home?region=${AWS::Region}#/topic/${AlertsTopic}
  DynamoDBTrackingTableConsoleURL:
    Description: DynamoDB table console URL
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/dynamodbv2/home?region=${AWS::Region}#item-explorer?maximize=true&operation=QUERY&table=${TrackingTable}
  DynamoDBConcurrencyTableConsoleURL:
    Description: DynamoDB table console URL
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/dynamodbv2/home?region=${AWS::Region}#item-explorer?maximize=true&operation=QUERY&table=${ConcurrencyTable}
  LambdaLookupFunctionName:
    Description: Name of the Lookup function
    Value: !Ref LookupFunction
  LambdaLookupFunctionConsoleURL:
    Description: Lambda function console URL
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/lambda/home?region=${AWS::Region}#/functions/${LookupFunction}
  SQSDocumentQueueUrl:
    Description: SQS Queue URL
    Value: !Ref DocumentQueue
  SQSDocumentQueueConsoleURL:
    Description: SQS Queue console URL
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/sqs/v2/home?region=${AWS::Region}#/queues/${DocumentQueue}
  SettingsParameterName:
    Description: Name of the Parameter store that holds configuration settings
    Value: !Ref SettingsParameter
  GraphQLApiUrl:
    Description: AppSync GraphQL API URL
    Value: !GetAtt GraphQLApi.GraphQLUrl
